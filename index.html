
<!DOCTYPE html>
<html>
<head>
    <title>Sokoban AI SOLVER: IDE & Level Editor</title>
    <style>
        body { background-color: #0d1117; color: #c9d1d9; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        .panel { width: 600px; background: #161b22; padding: 15px; border-radius: 8px 8px 0 0; border: 1px solid #30363d; display: flex; flex-direction: column; gap: 10px; }
        .panel-title { text-align: center; font-size: 14px; font-weight: bold; color: #58a6ff; text-transform: uppercase; letter-spacing: 1px; padding-bottom: 5px; }
        .editor-zone { display: flex; gap: 10px; height: 160px; }
        textarea { flex: 3; background: #010409; color: #7ee787; border: 1px solid #30363d; font-family: 'Consolas', monospace; font-size: 11px; padding: 10px; box-sizing: border-box; resize: none; }
        .sidebar { flex: 1; display: flex; flex-direction: column; gap: 5px; background: #0d1117; padding: 5px; border: 1px solid #30363d; border-radius: 4px; }
        .sidebar-title { font-size: 9px; color: #8b949e; text-transform: uppercase; font-weight: bold; padding: 2px; }
        .menu-opt { font-size: 10px; padding: 6px; background: #21262d; border: 1px solid #30363d; cursor: pointer; border-radius: 3px; text-align: center; transition: 0.2s; }
        .menu-opt.active { background: #1f6feb; border-color: #58a6ff; color: white; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button { padding: 12px; cursor: pointer; border: none; font-weight: bold; border-radius: 4px; font-size: 11px; background: #21262d; color: #c9d1d9; border: 1px solid #30363d; }
        button:hover { background: #30363d; border-color: #58a6ff; }
        .grid { display: grid; grid-template-columns: repeat(15, 30px); grid-template-rows: repeat(15, 30px); border: 5px solid #30363d; background-color: #010409; margin-top: -1px; }
        .cell { width: 30px; height: 30px; border: 1px solid rgba(255,255,255,0.02); display: flex; align-items: center; justify-content: center; font-size: 18px; cursor: crosshair; }
        .cell:hover { background-color: rgba(88, 166, 255, 0.1); }
        .wall { background-color: #21262d !important; border: 1px solid #484f58 !important; }
        .target { background-color: #0e4429 !important; }
        .player { background-color: #1f6feb; border-radius: 50%; z-index: 10; border: 2px solid #fff; }
        .box { background-color: #d29922; border-radius: 4px; z-index: 5; border: 1px solid #000; }
        .box-on-target { background-color: #8957e5; border-radius: 4px; z-index: 5; border: 2px solid #fff; }
        .active-box { outline: 3px solid #58a6ff; outline-offset: -3px; }
        #log { width: 600px; height: 160px; background: #010409; color: #7ee787; font-family: 'Consolas', monospace; padding: 12px; font-size: 11px; border: 1px solid #30363d; border-top: none; overflow-y: auto; border-radius: 0 0 8px 8px; line-height: 1.5; }
    </style>
</head>
<body>
    <div class="panel">
        <div class="panel-title">Sokoban AI: Level Editor IDE</div>
        <div class="editor-zone">
            <textarea id="config">{
  "nBoxes": 4,
  "nWalls": 24,
  "msg": "THE FOLLOWING LINES ARE CONSIDERED Advanced settings, SO PLEASE DO NOT EDIT THEM, UNLESS YOU KNOW WHAT YOU ARE DOING",
  "solverMode": 1,
  "animSpeed": 320,
  "maxSegments": 10,
  "aBoxes": [],
  "aTargets": [],
  "aWalls": [],
  "iPlayer": 0,
  "nameCreator": "randomX ArtInt",
  "dateCreated": ""
}</textarea>
            <div class="sidebar">
                <div class="sidebar-title">Mode Selection</div>
                <div class="menu-opt active" onclick="setMode(0)">RANDOM GEN</div>
                <div class="menu-opt" onclick="setMode(1)">LOAD / SAVE</div>
                <div class="menu-opt" onclick="setMode(2)">TOGGLE WALLS</div>
                <div class="menu-opt" onclick="setMode(3)">TOGGLE BOX/TGT</div>
            </div>
        </div>
        <div class="btn-group">
            <button onclick="initGame()" style="color: #3fb950;">1. SYNC & GENERATE</button>
            <button onclick="solve()" style="color: #58a6ff;">2. ANALYZE & SOLVE</button>
        </div>
    </div>
    <div id="game-grid" class="grid"></div>
    <div id="log"></div>

<script>
    const SIZE = 15;
    let layout = { walls:[], targets:[], player:{}, boxes:[] };
    let wallIndices = new Set();
    let boxIndices = [];
    let targetIndices = [];
    let currentMode = 0; // 0:Random, 1:Load, 2:Walls, 3:Entities

    const getIdx = (r, c) => r * SIZE + c;
    const getCoords = (idx) => ({ r: Math.floor(idx / SIZE), c: idx % SIZE });

    function setMode(m) {
        currentMode = m;
        document.querySelectorAll('.menu-opt').forEach((el, i) => el.classList.toggle('active', i === m));
        log(`Switched to: ${document.querySelectorAll('.menu-opt')[m].innerText}`);
    }

    function initGame() {
        const configArea = document.getElementById('config');
        let cfg = JSON.parse(configArea.value);
        const grid = document.getElementById('game-grid');
        grid.innerHTML = ''; wallIndices.clear();

        // Build Grid with Click Listeners
        for(let i=0; i<225; i++) {
            const d = document.createElement('div'); 
            d.id = `idx${i}`; d.className = 'cell';
            d.onclick = () => handleCellClick(i);
            grid.appendChild(d);
        }

        if (currentMode === 0) {
            // RANDOM GENERATION
            boxIndices = [];
			
			//COPILOT CREATION, WHILE ALMOST EVERYTHING ELSE IS GEMINI CREATION
			const topC = [...Array(SIZE).keys()]; 
			const bottomC = topC.map(i => i + SIZE * (SIZE - 1)); 
			const leftC = Array.from({length: SIZE}, (_, r) => r * SIZE); 
			const rightC = leftC.map(i => i + (SIZE - 1)); 
			const borderC = [...new Set([...topC, ...bottomC, ...leftC, ...rightC])];
			const edgeExclusions = new Uint8Array([...borderC]);
            //const edgeExclusions = new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,29,30,44,45,59,60,74,75,89,90,104,105,119,120,134,135,149,150,164,165,179,180,194,195,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224]);
            
			while(boxIndices.length < cfg.nBoxes) {
                let idx = 32 + Math.floor(Math.random() * 160);
                if (!boxIndices.includes(idx) && !edgeExclusions.includes(idx)) boxIndices.push(idx);
            }
            let others = [];
            while(others.length < 1 + cfg.nBoxes + cfg.nWalls) {
                let idx = Math.floor(Math.random() * 225);
                if (!boxIndices.includes(idx) && !others.includes(idx)) others.push(idx);
            }
            cfg.iPlayer = others[0];
            targetIndices = others.slice(1, 1 + cfg.nBoxes).sort((a,b)=>a-b);
            cfg.aWalls = others.slice(1 + cfg.nBoxes);
        } else {
            // LOAD FROM CONFIG
            boxIndices = cfg.aBoxes;
            targetIndices = cfg.aTargets;
        }

        // Apply Config to Layout
        layout.player = getCoords(cfg.iPlayer);
        layout.boxes = boxIndices.sort((a,b)=>a-b).map(getCoords);
        layout.targets = targetIndices.sort((a,b)=>a-b).map(getCoords);
        cfg.aWalls.forEach(idx => wallIndices.add(idx));

        syncConfig();
        drawBoard();
        renderEntities(layout.player, layout.boxes, -1);
        log("Map Ready.");
    }


    function isCornered(r, c) {
        const up = wallIndices.has(getIdx(r-1, c)) || r === 0;
        const down = wallIndices.has(getIdx(r+1, c)) || r === SIZE-1;
        const left = wallIndices.has(getIdx(r, c-1)) || c === 0;
        const right = wallIndices.has(getIdx(r, c+1)) || c === SIZE-1;
        return (up && left) || (up && right) || (down && left) || (down && right);
    }

function handleCellClick(idx) {
    const cfg = JSON.parse(document.getElementById('config').value);
    
    if (currentMode === 2) { 
        // Mode 2: Toggle Walls
        // Remove from other entity lists if making it a wall
        boxIndices = boxIndices.filter(i => i !== idx);
        targetIndices = targetIndices.filter(i => i !== idx);
        
        wallIndices.has(idx) ? wallIndices.delete(idx) : wallIndices.add(idx);
        
    } else if (currentMode === 3) { 
        // Mode 3: Toggle BOX -> TARGET -> BLANK
        // Remove wall if placing an entity
        wallIndices.delete(idx);

        if (boxIndices.includes(idx)) {
            // If it was a box, move it to target
            boxIndices = boxIndices.filter(i => i !== idx);
			document.getElementById(`idx${idx}`).innerText = '';
            targetIndices.push(idx);
        } else if (targetIndices.includes(idx)) {
            // If it was a target, make it blank
            targetIndices = targetIndices.filter(i => i !== idx);
            // Explicitly clear the emoji from the DOM for this cell
            document.getElementById(`idx${idx}`).innerText = '';
        } else {
            // If it was blank, make it a box
            boxIndices.push(idx);
        }
        
        // Update the coordinates for the solver
        layout.boxes = boxIndices.map(getCoords);
        layout.targets = targetIndices.map(getCoords);
    }

    syncConfig();
    drawBoard();
    renderEntities(layout.player, layout.boxes, -1);
}

    function syncConfig() {
        const area = document.getElementById('config');
        let cfg = JSON.parse(area.value);
        cfg.aBoxes = boxIndices.sort((a,b)=>a-b);
        cfg.aTargets = targetIndices.sort((a,b)=>a-b);
        cfg.aWalls = Array.from(wallIndices).sort((a,b)=>a-b);
        cfg.nBoxes = boxIndices.length;
        cfg.dateCreated = new Date().toLocaleString();
        area.value = JSON.stringify(cfg, null, 2);
    }

    // ... [Previous Solver functions: isCornered, findPath, findMacroPath, solve, generatePermutations, executeAnimation remain the same] ...

    async function solve() {
	    const cfg = JSON.parse(document.getElementById('config').value);
	        // Initial Corner Check (Walls only)
        for (let i = 0; i < layout.boxes.length; i++) {
            let b = layout.boxes[i];
            if (isCornered(b.r, b.c)) {
                if (!layout.targets.some(t => t.r === b.r && t.c === b.c)) {
                    log(`<span style='color:#f85149'>Abort: Box ${i} is cornered by walls.</span>`);
                    return;
                }
            }
        }
	const mode = cfg.solverMode || 1; 
    
    log(`<b>Starting Solver [Mode: ${mode}] [Seg Limit: ${cfg.maxSegments}]</b>`);
    
    // Preparation
    const boxIdxs = layout.boxes.map((_, i) => i);
    const targetIdxs = layout.targets.map((_, i) => i);

    let orderPerms, targetPerms;

    // --- STRATEGY SELECTION ---
    if (mode === 1) {
        // Mode 1: Basic (Box 0 -> Target 0, etc.)
        orderPerms = [boxIdxs]; 
        targetPerms = [targetIdxs];
    } else if (mode === 2) {
        // Mode 2: Target Carousel (Fixed Order, All Target Combos)
        orderPerms = [boxIdxs];
        targetPerms = generatePermutations(targetIdxs);
    } else if (mode === 3) {
        // Mode 3: Box Carousel (Fixed Targets, All Order Combos)
        orderPerms = generatePermutations(boxIdxs);
        targetPerms = [targetIdxs];
    } else {
        // Mode 4: Deep Search (The "Nuclear" Option)
        orderPerms = generatePermutations(boxIdxs);
        targetPerms = generatePermutations(targetIdxs);
    }

    const totalCombos = orderPerms.length * targetPerms.length;
    let comboCount = 0;

    for (let op of orderPerms) {
        for (let tp of targetPerms) {
            comboCount++;
            
            // Detailed Logging
            log(`<span style="color: #8b949e">Combo ${comboCount}/${totalCombos}: Order [${op}] | Targets [${tp}]</span>`);

            let boxes = layout.boxes.map(b => ({...b}));
            let player = {...layout.player};
            let anims = [];
            let ok = true;

            // Execute the Timeline (Order of boxes)
            for (let i = 0; i < boxes.length; i++) {
                let currBoxIdx = op[i]; 
                let assignedTargetIdx = tp[currBoxIdx];
                
                let m = findMacroPath(
                    boxes[currBoxIdx], 
                    layout.targets[assignedTargetIdx], 
                    boxes, 
                    player, 
                    currBoxIdx, 
                    cfg.maxSegments
                );

                if (m) {
                    log(`&nbsp; <small style="color: #58a6ff">Step ${i+1}: Box ${currBoxIdx} â†’ Target ${assignedTargetIdx} OK</small>`);
                    
                    m.forEach(seg => {
                        if (seg.reach) seg.reach.forEach(pos => { 
                            player = {...pos}; 
                            anims.push({p:{...pos}, b:boxes.map(bx=>({...bx})), active:currBoxIdx}); 
                        });
                        seg.segPath.forEach(bPos => { 
                            player = {...boxes[currBoxIdx]}; 
                            boxes[currBoxIdx] = {...bPos}; 
                            anims.push({p:{...player}, b:boxes.map(bx=>({...bx})), active:currBoxIdx}); 
                        });
                    });
                } else { 
                    ok = false; 
                    log(`&nbsp; <small style="color: #f85149">Failed: Box ${currBoxIdx} blocked at Step ${i+1}</small>`);
                    break; 
                }
            }

            if (ok) { 
                log(`<b><span style="color: #3fb950">SOLVED! found at Combo ${comboCount}</span></b>`); 
                log(`<i>Final Timeline: ${op.join(' â†’ ')}</i>`);
                executeAnimation(anims, cfg.animSpeed); 
                return; 
            }
        }
    }
    log("<span style='color:#f85149'><b>Search Exhausted:</b> No sequence works in Mode " + mode + "</span>");
}

    function generatePermutations(arr) {
        let res = [];
        const p = (m, c = []) => { if (m.length === 0) res.push(c); else { for (let i=0; i<m.length; i++) { let cur = m.slice(); let n = cur.splice(i, 1); p(cur, c.concat(n)); } } };
        p(arr); return res;
    }

    function findPath(start, goal, boxesAtThatMoment) {
        if(start.r === goal.r && start.c === goal.c) return [];
        let obstacles = new Set(wallIndices);
        boxesAtThatMoment.forEach(b => obstacles.add(getIdx(b.r, b.c)));
        if (obstacles.has(getIdx(goal.r, goal.c))) return null;
        let open = [{r: start.r, c: start.c, path: []}], visited = new Set([getIdx(start.r, start.c)]);
        while(open.length > 0) {
            let curr = open.shift();
            if(curr.r === goal.r && curr.c === goal.c) return curr.path;
            for(let [dr,dc] of [[0,1],[0,-1],[1,0],[-1,0]]) {
                let nr=curr.r+dr, nc=curr.c+dc, nIdx=getIdx(nr,nc);
                if(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE && !obstacles.has(nIdx) && !visited.has(nIdx)) {
                    visited.add(nIdx);
                    open.push({r: nr, c: nc, path: [...curr.path, {r:nr, c:nc}]});
                }
            }
        }
        return null;
    }

    function findMacroPath(startBox, goalTarget, allBoxes, startPlayer, movingIdx, maxSeg) {
        let queue = [{ boxPos: {...startBox}, playerPos: {...startPlayer}, boxesState: allBoxes.map(b => ({...b})), segments: [] }];
        let visited = new Set();
        while(queue.length > 0) {
            let curr = queue.shift();
            let key = `${getIdx(curr.boxPos.r, curr.boxPos.c)}|${getIdx(curr.playerPos.r, curr.playerPos.c)}`;
            if(visited.has(key)) continue; visited.add(key);
            if(curr.boxPos.r === goalTarget.r && curr.boxPos.c === goalTarget.c) return curr.segments;
            if(curr.segments.length >= maxSeg) continue;
            for(let [dr, dc] of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let pushSide = { r: curr.boxPos.r - dr, c: curr.boxPos.c - dc };
                let reach = findPath(curr.playerPos, pushSide, curr.boxesState);
                if(!reach && getIdx(curr.playerPos.r, curr.playerPos.c) !== getIdx(pushSide.r, pushSide.c)) continue;
                for(let dist = 1; dist < SIZE; dist++) {
                    let nR = curr.boxPos.r + dr * dist, nC = curr.boxPos.c + dc * dist;
                    if(nR < 0 || nR >= SIZE || nC < 0 || nC >= SIZE) break;
                    if(wallIndices.has(getIdx(nR, nC)) || curr.boxesState.some((b, k) => k !== movingIdx && b.r === nR && b.c === nC)) break;
                    let newBoxPos = { r: nR, c: nC }, newPlayerPos = { r: nR - dr, c: nC - dc };
                    let nBoxes = curr.boxesState.map((b, k) => k === movingIdx ? newBoxPos : b);
                    let sPath = []; for(let i=1; i<=dist; i++) sPath.push({r: curr.boxPos.r + dr*i, c: curr.boxPos.c + dc*i});
                    queue.push({ boxPos: newBoxPos, playerPos: newPlayerPos, boxesState: nBoxes, segments: [...curr.segments, { reach, segPath: sPath }] });
                }
            }
        }
        return null;
    }

    async function executeAnimation(q, spd) {
        for(let f of q) { renderEntities(f.p, f.b, f.active); await new Promise(r => setTimeout(r, 450 - spd)); }
    }

    function drawBoard() {
        for(let i=0; i<225; i++) {
            let el = document.getElementById(`idx${i}`);
            el.className = 'cell' + (wallIndices.has(i) ? ' wall' : '') + (targetIndices.includes(i) ? ' target' : '');
        }
    }

    function renderEntities(p, boxes, activeIdx) {
        document.querySelectorAll('.player, .box, .box-on-target, .active-box').forEach(e => { e.classList.remove('player','box','box-on-target','active-box'); e.innerText=''; });
        boxes.forEach((b, idx) => {
            let idxVal = getIdx(b.r, b.c);
            let el = document.getElementById(`idx${idxVal}`);
            if(!el) return;
            el.classList.add(targetIndices.includes(idxVal) ? 'box-on-target' : 'box');
            if(idx === activeIdx) el.classList.add('active-box');
            el.innerText = 'ðŸ“¦';
        });
        let pEl = document.getElementById(`idx${getIdx(p.r,p.c)}`);
        if(pEl) { pEl.classList.add('player'); pEl.innerText = 'ðŸ‘¤'; }
    }

    function log(m) { const l=document.getElementById('log'); l.innerHTML += `> ${m}<br>`; l.scrollTop = l.scrollHeight; }
    initGame();
</script>
</body>
</html>