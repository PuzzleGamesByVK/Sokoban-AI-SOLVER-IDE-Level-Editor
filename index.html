
<!DOCTYPE html>
<html>
<head>
    <title>Sokoban AI SOLVER: IDE & Level Editor</title>
    <style>
        body { 
            background-color: #0d1117; 
            color: #c9d1d9; 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 10px; /* Reduced padding for mobile edges */
            margin: 0; 
        }
		.panel { 
            width: 450px; 
            background: #161b22; 
            padding: 12px; 
            border-radius: 8px 8px 0 0; 
            border: 1px solid #30363d; 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
            box-sizing: border-box; /* Ensures padding doesn't push width past 450px */
        }
        .panel-title { 
            text-align: center; 
            font-size: 15px; /* Slightly smaller for narrow layout */
            font-weight: bold; 
            color: #58a6ff; 
            text-transform: uppercase; 
            letter-spacing: 1px; 
            padding-bottom: 2px; 
        }
        .editor-zone { 
            display: flex; 
            gap: 8px; 
            height: 180px; /* Increased height slightly for better visibility in narrow view */
        }
        textarea { 
            flex: 2; /* Adjusted ratio for 450px width */
            background: #010409; 
            color: #7ee787; 
            border: 1px solid #30363d; 
            font-family: 'Consolas', monospace; 
            font-size: 12px; /* Smaller?*/
            padding: 8px; 
            box-sizing: border-box; 
            resize: none; 
        }
        .sidebar { 
            flex: 1.2; /* Giving sidebar slightly more room for button text */
            display: flex; 
            flex-direction: column; 
            gap: 4px; 
            background: #0d1117; 
            padding: 4px; 
            border: 1px solid #30363d; 
            border-radius: 4px; 
        }
        .sidebar-title { 
            font-size: 12px; 
            color: #8b949e; 
            text-transform: uppercase; 
            font-weight: bold; 
            padding: 2px; 
            text-align: center;
        }
        .menu-opt { 
            font-size: 12px; 
            padding: 5px; 
            background: #21262d; 
            border: 1px solid #30363d; 
            cursor: pointer; 
            border-radius: 3px; 
            text-align: center; 
            transition: 0.2s; 
        }
        .menu-opt.active { background: #1f6feb; border-color: #58a6ff; color: white; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr;     gap: 7px; }
        button { 
            padding: 10px 5px; 
            cursor: pointer; 
            border: none; 
            font-weight: bold; 
            border-radius: 4px; 
            font-size: 14px; 
            background: #21262d; 
            color: #c9d1d9; 
            border: 1px solid #30363d; 
        }
        button:hover { background: #30363d; border-color: #58a6ff; }
        .grid { 
            display: grid; 
            grid-template-columns: repeat(15, 30px); 
            grid-template-rows: repeat(15, 30px); 
            border: 1px solid #30363d; /* Reduced border thickness to align better */
            background-color: #010409; 
            margin-top: -1px; 
            box-sizing: content-box;
        }
        .cell { width: 30px; height: 30px; border: 1px solid rgba(255,255,255,0.02); display: flex; align-items: center; justify-content: center; font-size: 18px; cursor: crosshair; }
        .cell:hover { background-color: rgba(88, 166, 255, 0.1); }
        .wall { background-color: #21262d !important; border: 1px solid #484f58 !important; }
        .target { background-color: #0e4429 !important; }
        .player { background-color: #1f6feb; border-radius: 50%; z-index: 10; border: 2px solid #fff; }
        .box { background-color: #d29922; border-radius: 4px; z-index: 5; border: 1px solid #000; }
        .box-on-target { background-color: #8957e5; border-radius: 4px; z-index: 5; border: 2px solid #fff; }
        .active-box { outline: 3px solid #58a6ff; outline-offset: -3px; }
        #log { 
            width: 450px; 
            height: 140px; 
            background: #010409; 
            color: #7ee787; 
            font-family: 'Consolas', monospace; 
            padding: 10px; 
            font-size: 11px; 
            border: 1px solid #30363d; 
            border-top: none; 
            overflow-y: auto; 
            border-radius: 0 0 8px 8px; 
            line-height: 1.4; 
            box-sizing: border-box;
        }
	.player.relocating { 		box-shadow: 0 0 15px #58a6ff;    animation: pulse-blue 1s infinite;	}
	@keyframes pulse-blue {    0% { transform: scale(1); }    50% { transform: scale(1.1); }    100% { transform: scale(1); }	}
    </style>
</head>
<body>
    <div class="panel">
        <div class="panel-title">Sokoban AI: Level Editor IDE</div>
        <div class="editor-zone">
            <textarea id="config">{
  "nBoxes": 4,
  "nWalls": 24,
  "msg": "THE FOLLOWING LINES ARE CONSIDERED Advanced settings, SO PLEASE DO NOT EDIT THEM, UNLESS YOU KNOW WHAT YOU ARE DOING",
  "solverMode": 1,
  "animSpeed": 340,
  "maxSegments": 10,
  "maxPermIterations": 576,
  "aBoxes": [],
  "aTargets": [],
  "aWalls": [],
  "iPlayer": 0,
  "nameCreator": "randomX ArtInt",
  "dateCreated": ""
}</textarea>
            <div class="sidebar">
                <div class="sidebar-title">Mode Selection</div>
                <div class="menu-opt active" onclick="setMode(0)">RANDOM GEN</div>
                <div class="menu-opt" onclick="setMode(1)">LOAD / SAVE</div>
                <div class="menu-opt" onclick="setMode(2)">TOGGLE WALLS</div>
                <div class="menu-opt" onclick="setMode(3)">TOGGLE BOX/TGT</div>
            </div>
        </div>
        <div class="btn-group">
            <button onclick="initGame()" style="color: #3fb950;">1. SYNC & GENERATE</button>
            <button onclick="solve()" style="color: #58a6ff;">2. ANALYZE & SOLVE</button>
        </div>
    </div>
    <div id="game-grid" class="grid"></div>
    <div id="log"></div>

<script>
    const SIZE = 15;
    let layout = { walls:[], targets:[], player:{}, boxes:[] };
    let wallIndices = new Set();
    let boxIndices = [];
    let targetIndices = [];
    let currentMode = 0; // 0:Random, 1:Load, 2:Walls, 3:Entities
	let isRelocatingPlayer = false; // Track if we are in "move player" mode
	let idxOLD = -1

    const getIdx = (r, c) => r * SIZE + c;//MAYBE AT OLDER VERSIONS
    const getCoords = (idx) => ({ r: Math.floor(idx / SIZE), c: idx % SIZE });//MAYBE AT OLDER VERSIONS

    function setMode(m) {
        currentMode = m;
        document.querySelectorAll('.menu-opt').forEach((el, i) => el.classList.toggle('active', i === m));
        log(`Switched to: ${document.querySelectorAll('.menu-opt')[m].innerText}`);
    }

    function initGame() {
        const configArea = document.getElementById('config');
        let cfg = JSON.parse(configArea.value);
		const grid = document.getElementById('game-grid');
        grid.innerHTML = ''; wallIndices.clear();

        // Build Grid with Click Listeners
        for(let i=0; i<225; i++) {//ONLY FOR 15x15 . IF 16x16 AND MORE CHANGE ...
            const d = document.createElement('div'); 
            d.id = `idx${i}`; d.className = 'cell';
            d.onclick = () => handleCellClick(i);
            grid.appendChild(d);
        }

        if (currentMode === 0) {
            // RANDOM GENERATION
            boxIndices = [];
			
			//COPILOT CREATION, WHILE ALMOST EVERYTHING ELSE IS GEMINI CREATION
			const topC = [...Array(SIZE).keys()]; 
			const bottomC = topC.map(i => i + SIZE * (SIZE - 1)); 
			const leftC = Array.from({length: SIZE}, (_, r) => r * SIZE); 
			const rightC = leftC.map(i => i + (SIZE - 1)); 
			const borderC = [...new Set([...topC, ...bottomC, ...leftC, ...rightC])];
			const edgeExclusions = new Uint8Array([...borderC]);//ONLY FOR 15x15. IF 16x16 AND MORE CHANGE TO Int16Array
            //const edgeExclusions = new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,29,30,44,45,59,60,74,75,89,90,104,105,119,120,134,135,149,150,164,165,179,180,194,195,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224]);
            
			while(boxIndices.length < cfg.nBoxes) {
                let idx = 32 + Math.floor(Math.random() * 160);
                if (!boxIndices.includes(idx) && !edgeExclusions.includes(idx)) boxIndices.push(idx);
            }
            let others = [];
            while(others.length < 1 + cfg.nBoxes + cfg.nWalls) {
                let idx = Math.floor(Math.random() * 225);
                if (!boxIndices.includes(idx) && !others.includes(idx)) others.push(idx);
            }
            cfg.iPlayer = others[0];
            targetIndices = others.slice(1, 1 + cfg.nBoxes).sort((a,b)=>a-b);
            cfg.aWalls = others.slice(1 + cfg.nBoxes);
        } else {
            // LOAD FROM CONFIG
            boxIndices = cfg.aBoxes;
            targetIndices = cfg.aTargets;
        }

        // Apply Config to Layout
        //layout.player = getCoords(cfg.iPlayer);
	layout.player = cfg.iPlayer; 
    boxIndices.sort((a,b)=>a-b);
    targetIndices.sort((a,b)=>a-b);
    cfg.aWalls.forEach(idx => wallIndices.add(idx));

        syncConfig();
        drawBoard();
        //renderEntities(layout.player, layout.boxes, -1);
		renderEntities(layout.player, boxIndices, -1);
        log("---<br>> Map Ready.");
    }


    function isCornered(r, c) {
        const up = wallIndices.has(getIdx(r-1, c)) || r === 0;
        const down = wallIndices.has(getIdx(r+1, c)) || r === SIZE-1;
        const left = wallIndices.has(getIdx(r, c-1)) || c === 0;
        const right = wallIndices.has(getIdx(r, c+1)) || c === SIZE-1;
        return (up && left) || (up && right) || (down && left) || (down && right);
    }

/* function isCornered(idx) {
    const r = Math.floor(idx / SIZE);
    const c = idx % SIZE;
    const up = wallIndices.has(idx - SIZE) || r === 0;
    const down = wallIndices.has(idx + SIZE) || r === SIZE - 1;
    const left = wallIndices.has(idx - 1) || c === 0;
    const right = wallIndices.has(idx + 1) || c === SIZE - 1;
    return (up && left) || (up && right) || (down && left) || (down && right);
}*/

function handleCellClick(idx) {
const cfg = JSON.parse(document.getElementById('config').value);
    // IF PLAYER IS CLICKED: Start relocation mode
    if (idx === layout.player && [2,3].includes(currentMode)) {
        isRelocatingPlayer = true;
        document.getElementById(`idx${idx}`).classList.add('relocating');
		idxOLD=idx;
        log("Select an empty cell to reposition the player...");
        
        // Auto-cancel after 5 seconds
        setTimeout(() => {
            if (isRelocatingPlayer) {
                isRelocatingPlayer = false;
                document.getElementById(`idx${idx}`).classList.remove('relocating');
                log("Repositioning timed out.");
            }
        }, 5000);
        return;
    }

    // IF RELOCATION IS ACTIVE: Move player to empty cell
    if (isRelocatingPlayer && [2,3].includes(currentMode)) {
        if (wallIndices.has(idx) || boxIndices.includes(idx)) {
            log("Cannot move player onto a wall or box!");
            return;
        }
        layout.player = idx;
		document.getElementById(`idx${idxOLD}`).innerHTML='';
        isRelocatingPlayer = false;
        log(`Player moved to index ${idx}`);
        syncConfig();
        drawBoard();
        renderEntities(layout.player, boxIndices, -1);
        return;
    }
    
// STANDARD MODE LOGIC
    if (currentMode === 2) { 
        boxIndices = boxIndices.filter(i => i !== idx);
        targetIndices = targetIndices.filter(i => i !== idx);
        wallIndices.has(idx) ? wallIndices.delete(idx) : wallIndices.add(idx);
   } else if (currentMode === 3) { 
        // Mode 3: Toggle BOX -> TARGET -> BLANK
        // Remove wall if placing an entity
        wallIndices.delete(idx);
		//
        if (boxIndices.includes(idx)) {
            // If it was a box, move it to target
            boxIndices = boxIndices.filter(i => i !== idx);
			document.getElementById(`idx${idx}`).innerText = '';
            targetIndices.push(idx);
        } else if (targetIndices.includes(idx)) {
            // If it was a target, make it blank
            targetIndices = targetIndices.filter(i => i !== idx);
            // Explicitly clear the emoji from the DOM for this cell
            document.getElementById(`idx${idx}`).innerText = '';
        } else {
            // If it was blank, make it a box
            boxIndices.push(idx);
        }
    }

    syncConfig();
    drawBoard();
    //renderEntities(layout.player, layout.boxes, -1);
	renderEntities(layout.player, boxIndices, -1);
}

function syncConfig() {
    const area = document.getElementById('config');
    let cfg = JSON.parse(area.value);
    cfg.aBoxes = boxIndices.sort((a,b)=>a-b);
    cfg.aTargets = targetIndices.sort((a,b)=>a-b);
    cfg.aWalls = Array.from(wallIndices).sort((a,b)=>a-b);
    cfg.iPlayer = layout.player; // Keep config in sync with moved player
    cfg.nBoxes = boxIndices.length;
    cfg.dateCreated = new Date().toLocaleString();
    area.value = JSON.stringify(cfg, null, 2);
}

 async function solve() {
    const configArea = document.getElementById('config');
    const cfg = JSON.parse(configArea.value);
    const mode = cfg.solverMode || 1;
    
    log(`<b>Starting Solver [Mode: ${mode}] [Seg Limit: ${cfg.maxSegments}]</b>`);
    
    // 1. Initial Deadlock Check (Using Index Math)
    for (let bIdx of boxIndices) {
        const r = Math.floor(bIdx / SIZE);
        const c = bIdx % SIZE;
        if (isCornered(r, c) && !targetIndices.includes(bIdx)) {
            log(`<span style='color:#f85149'>Abort: Box at ${bIdx} is cornered.</span>`);
            return;
        }
    }

    // 2. Prepare Permutations
    const boxRefIdxs = boxIndices.map((_, i) => i);
    const targetRefIdxs = targetIndices.map((_, i) => i);
    let orderPerms = (mode === 3 || mode === 4) ? generatePermutations(boxRefIdxs) : [boxRefIdxs];
    let targetPerms = (mode === 2 || mode === 4) ? generatePermutations(targetRefIdxs) : [targetRefIdxs];

    const totalCombos = orderPerms.length * targetPerms.length;
    let comboCount = 0;

    // 3. Main Search Loop
    for (let op of orderPerms) {
        for (let tp of targetPerms) {
            comboCount++;
            
            if (comboCount > cfg.maxPermIterations) {
                log(`<span style="color: #f85149">Safety Stop: Reached ${cfg.maxPermIterations}: maximum allowed Permutation iterations.</span>`);
                return;
            }

            log(`<span style="color: #8b949e">Combo ${comboCount}/${totalCombos}: Order [${op}] | Targets [${tp}]</span>`); // Detailed Logging

            // Current state for this permutation
            let currentBoxes = [...boxIndices];
            let currentPlayer = cfg.iPlayer;
            let totalAnims = [];
            let success = true;

            // Try to move each box in the chosen order to its assigned target
            for (let i = 0; i < currentBoxes.length; i++) {
                let boxToMoveIdx = op[i]; 
                let targetForThisBox = targetIndices[tp[boxToMoveIdx]];

                let resultSegments = findMacroPath(
                    currentBoxes[boxToMoveIdx],
                    targetForThisBox,
                    currentBoxes,
                    currentPlayer,
                    boxToMoveIdx,
                    cfg.maxSegments
                );

                if (resultSegments) {
                    // Update the state for the next box in the sequence
                    resultSegments.forEach(seg => {
                        // Add player movement (reach)
                        if (seg.reach) {
                            seg.reach.forEach(stepIdx => {
                                currentPlayer = stepIdx;
                                totalAnims.push({ p: currentPlayer, b: [...currentBoxes], active: boxToMoveIdx });
                            });
                        }
                        // Add box push
                        seg.segPath.forEach(stepIdx => {
                            currentPlayer = currentBoxes[boxToMoveIdx]; // Player moves to where box was
                            currentBoxes[boxToMoveIdx] = stepIdx;
                            totalAnims.push({ p: currentPlayer, b: [...currentBoxes], active: boxToMoveIdx });
                        });
                    });
                } else {
                    success = false;
                    break;
                }
            }

            if (success) {
                log(`<b><span style="color: #3fb950">SOLVED! found at Combo ${comboCount}</span></b>`);
				log(`<i>Final Timeline: ${op.join(' â†’ ')}</i>`);
                executeAnimation(totalAnims, cfg.animSpeed);
                return;
            }
        }
    }
    log("<span style='color:#f85149'><b>Search Exhausted:</b> No solution found in Mode " + mode + "</span>");
}

    function generatePermutations(arr) {
        let res = [];
        const p = (m, c = []) => { if (m.length === 0) res.push(c); else { for (let i=0; i<m.length; i++) { let cur = m.slice(); let n = cur.splice(i, 1); p(cur, c.concat(n)); } } };
        p(arr); return res;
    }

function findPath(startIdx, goalIdx, boxesAtThatMoment) {
    if (startIdx === goalIdx) return [];
    
    const totalCells = SIZE * SIZE;
    const parent = new Int16Array(totalCells).fill(-1);
    
    // FIXED: boxesAtThatMoment is now an array of indices, not objects
    let obstacles = new Set(wallIndices);
    boxesAtThatMoment.forEach(bIdx => obstacles.add(bIdx)); 
    
    if (obstacles.has(goalIdx)) return null;

    const LURD = [-1, -SIZE, 1, SIZE];
    let queue = [startIdx];
    parent[startIdx] = startIdx; 

    let head = 0; 
    
    while (head < queue.length) {
        let currIdx = queue[head++];

        if (currIdx === goalIdx) {
            let path = [];
            let step = goalIdx;
            while (step !== startIdx) {
                path.push(step);
                step = parent[step];
            }
            return path.reverse(); 
        }

        for (let offset of LURD) {
            let nIdx = currIdx + offset;

            // Boundary & Wrap-around Check
            if (nIdx < 0 || nIdx >= totalCells) continue;
            if (Math.abs(offset) === 1 && Math.floor(nIdx / SIZE) !== Math.floor(currIdx / SIZE)) continue;

            // Check if visited or obstacle
            if (parent[nIdx] === -1 && !obstacles.has(nIdx)) {
                parent[nIdx] = currIdx; 
                queue.push(nIdx);
            }
        }
    }
    return null;
}

function findMacroPath(startBoxIdx, goalTargetIdx, allBoxesIdx, startPlayerIdx, movingIdx, maxSeg) {
    // 1. Initialize State Tracking
    // We use a large Int8Array to track visited [BoxPos][PlayerPos] states.
    // Max index is 224, so 225 * 225 = 50,625 possible states.                   NOTE: THIS FUNCTION IS ONLY FOR 15x15! IN CASE OF 16x16 OR MORE WE WOULD NEED DIFFERENT APROACH.
    const visitedStates = new Int8Array(50625); 

    // Queue stores objects, but now using simple integers for positions
    let queue = [{ 
        boxIdx: startBoxIdx, 
        playerIdx: startPlayerIdx, 
        boxesState: [...allBoxesIdx], 
        segments: [] 
    }];

    let head = 0;
    const LURD = [-1, -SIZE, 1, SIZE];

    while (head < queue.length) {
        let curr = queue[head++];

        // 2. Mathematical Key for visited check: (Box * 225) + Player
        // This is more memory efficient than 100,000*x+y and fits perfectly.
        let stateKey = (curr.boxIdx * 225) + curr.playerIdx;
        if (visitedStates[stateKey] === 1) continue;
        visitedStates[stateKey] = 1;

        // 3. Goal Check
        if (curr.boxIdx === goalTargetIdx) return curr.segments;
        if (curr.segments.length >= maxSeg) continue;

        // 4. Try pushing in 4 directions
        for (let offset of LURD) {
            let pushSideIdx = curr.boxIdx - offset;

            // Boundary check for pushSide
            if (pushSideIdx < 0 || pushSideIdx >= 225) continue;
            if (Math.abs(offset) === 1 && Math.floor(pushSideIdx/SIZE) !== Math.floor(curr.boxIdx/SIZE)) continue;

            // Can player reach the pushing side?
            let reach = findPath(curr.playerIdx, pushSideIdx, curr.boxesState);
            
            // If reach is null, check if player is already standing there
            if (!reach && curr.playerIdx !== pushSideIdx) continue;

            // 5. Try pushing the box forward as many cells as possible (Macro Move)
            for (let dist = 1; dist < SIZE; dist++) {
                let nBoxIdx = curr.boxIdx + (offset * dist);
                
                // Boundary and Obstacle Check
                if (nBoxIdx < 0 || nBoxIdx >= 225) break;
                if (Math.abs(offset) === 1 && Math.floor(nBoxIdx/SIZE) !== Math.floor(curr.boxIdx/SIZE)) break;
                if (wallIndices.has(nBoxIdx) || curr.boxesState.some((bIdx, k) => k !== movingIdx && bIdx === nBoxIdx)) break;

                // New State calculation
                let newBoxIdx = nBoxIdx;
                let newPlayerIdx = nBoxIdx - offset; // Player ends up behind the box
                let nBoxesState = curr.boxesState.map((bIdx, k) => k === movingIdx ? newBoxIdx : bIdx);
                
                // Construct Segment Path for animation
                let sPath = [];
                for (let i = 1; i <= dist; i++) sPath.push(curr.boxIdx + offset * i);

                queue.push({
                    boxIdx: newBoxIdx,
                    playerIdx: newPlayerIdx,
                    boxesState: nBoxesState,
                    segments: [...curr.segments, { reach, segPath: sPath }]
                });
            }
        }
    }
    return null;
}

async function executeAnimation(queue, speed) {
    // The higher the speed value in config, the lower the delay
    const delay = Math.max(10, 500 - speed); 
    for (let frame of queue) {
        // frame.p and frame.b are now single integers and flat arrays
        renderEntities(frame.p, frame.b, frame.active);
        // Wait for the next frame
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    log("<span style='color: #3fb950'>Animation Complete.</span>");
}

    function drawBoard() {
        for(let i=0; i<225; i++) {
            let el = document.getElementById(`idx${i}`);
            el.className = 'cell' + (wallIndices.has(i) ? ' wall' : '') + (targetIndices.includes(i) ? ' target' : '');
        }
    }

function renderEntities(pIdx, boxesIdxs, activeBoxIdx) {
    // 1. Efficiently clear only the dynamic classes and emojis
    document.querySelectorAll('.player, .box, .box-on-target, .active-box').forEach(e => { 
        e.classList.remove('player', 'box', 'box-on-target', 'active-box'); 
        e.innerText = ''; 
    });

    // 2. Render Boxes using the index array
    boxesIdxs.forEach((bIdx, idx) => {
        const el = document.getElementById(`idx${bIdx}`);
        if (!el) return;

        // Check if the box is on a target index for styling
        const isOnTarget = targetIndices.includes(bIdx);
        el.classList.add(isOnTarget ? 'box-on-target' : 'box');
        
        // If this is the box currently being pushed by the AI
        if (idx === activeBoxIdx) el.classList.add('active-box');
        
        el.innerText = 'ðŸ“¦';
    });

    // 3. Render Player at their index
    const pEl = document.getElementById(`idx${pIdx}`);
    if (pEl) { 
        pEl.classList.add('player'); 
        pEl.innerText = 'ðŸ‘¤'; 
    }
}

    function log(m) { const l=document.getElementById('log'); l.innerHTML += `> ${m}<br>`; l.scrollTop = l.scrollHeight; }
    initGame();
</script>
</body>
</html>
